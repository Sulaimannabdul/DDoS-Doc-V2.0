using System;
using System.Runtime.Serialization;
using Lime.Protocol.Security;

namespace Lime.Protocol
{
    /// <summary>
    /// Allows the configuration and establishment of the communication channel between nodes. 
    /// </summary>
    [DataContract(Namespace = "http://limeprotocol.org/2014")]
    public class Session : Envelope
    {
        public const string STATE_KEY = "state";
        public const string MODE_KEY = "mode";
        public const string ENCRYPTION_OPTIONS_KEY = "encryptionOptions";
        public const string ENCRYPTION_KEY = "encryption";
        public const string COMPRESSION_OPTIONS_KEY = "compressionOptions";
        public const string COMPRESSION_KEY = "compression";
        public const string SCHEME_OPTIONS_KEY = "schemeOptions";
        public const string SCHEME_KEY = "scheme";
        public const string AUTHENTICATION_KEY = "authentication";
        public const string REASON_KEY = "reason";

        /// <summary>
        /// Initializes a new instance of the <see cref="Session"/> class.
        /// </summary>
        public Session()
            : base(null)
        {
            // The session id is generated by the server
            // The session id is generated by the server
        }

        /// <summary>
        /// Informs or changes the state of a session. 
        /// Only the server can change the session state, but the client can request the state transition. 
        /// </summary>
        [DataMember(Name = STATE_KEY)]
        public SessionState State { get; set; }

        /// <summary>
        /// Encryption options provided by the server during the session negotiation.
        /// </summary>
        [DataMember(Name = ENCRYPTION_OPTIONS_KEY, EmitDefaultValue = false)]
        public SessionEncryption[] EncryptionOptions { get; set; }

        /// <summary>
        /// The encryption option selected for the session. 
        /// This property is provided by the client in the 
        /// negotiation and by the server in the confirmation 
        /// after that.
        /// </summary>
        [DataMember(Name = ENCRYPTION_KEY)]
        public SessionEncryption? Encryption { get; set; }

        /// <summary>
        /// Compression options provided by the 
        /// server during the session negotiation.
        /// </summary>
        [DataMember(Name = COMPRESSION_OPTIONS_KEY, EmitDefaultValue = false)]
        public SessionCompression[] CompressionOptions { get; set; }

        /// <summary>
        /// The compression option selected for the session. 
        /// This property is provided by the client in the 
        /// negotiation and by the server in the confirmation 
        /// after that.
        /// </summary>
        [DataMember(Name = COMPRESSION_KEY)]
        public SessionCompression? Compression { get; set; }

        /// <summary>
        /// List of available authentication schemas 
        /// for session authentication provided by the server.
        /// </summary>
        [DataMember(Name = SCHEME_OPTIONS_KEY)]
        public AuthenticationScheme[] SchemeOptions { get; set; }

        /// <summary>
        /// The authentication scheme option selected 
        /// for the session. This property must be present 
        /// if the property authentication is defined.
        /// </summary>
        [DataMember(Name = SCHEME_KEY)]
        public AuthenticationScheme? Scheme => Authentication?.GetAuthenticationScheme();

        /// <summary>
        /// Authentication data, related to the selected schema. 
        /// Information like password sent by the client or 
        /// roundtrip data sent by the server.
        /// </summary>
        [DataMember(Name = AUTHENTICATION_KEY)]
        public Authentication Authentication { get; set; }

        /// <summary>
        /// In cases where the client receives a session with 
        /// failed state, this property should provide more 
        /// details about the problem.
        /// </summary>
        [DataMember(Name = REASON_KEY)]
        public Reason Reason { get; set; }       
    }
}
